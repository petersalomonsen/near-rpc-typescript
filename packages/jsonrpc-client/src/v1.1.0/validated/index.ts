// Auto-generated validation wrapper functions
// Generated at: 2025-08-02T12:20:02.967Z
// Total functions: 28
//
// This file is automatically generated by tools/codegen/generate-validation-wrappers.ts
// Do not edit manually - changes will be overwritten

import type { NearRpcClient } from '../client.js';
import * as baseFunctions from '../generated-functions.js';
import type {
  AccessKeyView,
  AccountView,
  CallResult,
  CryptoHash,
  EXPERIMENTALMaintenanceWindowsResponse,
  EXPERIMENTALValidatorsOrderedResponse,
  GenesisConfig,
  GenesisConfigRequest,
  RpcBlockRequest,
  RpcBlockResponse,
  RpcChunkRequest,
  RpcChunkResponse,
  RpcClientConfigRequest,
  RpcClientConfigResponse,
  RpcCongestionLevelRequest,
  RpcCongestionLevelResponse,
  RpcGasPriceRequest,
  RpcGasPriceResponse,
  RpcHealthRequest,
  RpcHealthResponse,
  RpcLightClientBlockProofRequest,
  RpcLightClientBlockProofResponse,
  RpcLightClientExecutionProofRequest,
  RpcLightClientExecutionProofResponse,
  RpcLightClientNextBlockRequest,
  RpcLightClientNextBlockResponse,
  RpcMaintenanceWindowsRequest,
  RpcNetworkInfoRequest,
  RpcNetworkInfoResponse,
  RpcProtocolConfigRequest,
  RpcProtocolConfigResponse,
  RpcQueryRequest,
  RpcQueryResponse,
  RpcReceiptRequest,
  RpcReceiptResponse,
  RpcSendTransactionRequest,
  RpcSplitStorageInfoRequest,
  RpcSplitStorageInfoResponse,
  RpcStateChangesInBlockByTypeRequest,
  RpcStateChangesInBlockByTypeResponse,
  RpcStateChangesInBlockRequest,
  RpcStateChangesInBlockResponse,
  RpcStatusRequest,
  RpcStatusResponse,
  RpcTransactionResponse,
  RpcTransactionStatusRequest,
  RpcValidatorRequest,
  RpcValidatorResponse,
  RpcValidatorsOrderedRequest,
} from '@near-js/jsonrpc-types';
import {
  CryptoHashSchema,
  GenesisConfigRequestSchema,
  GenesisConfigSchema,
  RpcBlockRequestSchema,
  RpcBlockResponseSchema,
  RpcChunkRequestSchema,
  RpcChunkResponseSchema,
  RpcClientConfigRequestSchema,
  RpcClientConfigResponseSchema,
  RpcCongestionLevelRequestSchema,
  RpcCongestionLevelResponseSchema,
  RpcGasPriceRequestSchema,
  RpcGasPriceResponseSchema,
  RpcHealthRequestSchema,
  RpcHealthResponseSchema,
  RpcLightClientBlockProofRequestSchema,
  RpcLightClientBlockProofResponseSchema,
  RpcLightClientExecutionProofRequestSchema,
  RpcLightClientExecutionProofResponseSchema,
  RpcLightClientNextBlockRequestSchema,
  RpcLightClientNextBlockResponseSchema,
  RpcMaintenanceWindowsRequestSchema,
  RpcNetworkInfoRequestSchema,
  RpcNetworkInfoResponseSchema,
  RpcProtocolConfigRequestSchema,
  RpcProtocolConfigResponseSchema,
  RpcQueryRequestSchema,
  RpcQueryResponseSchema,
  RpcReceiptRequestSchema,
  RpcReceiptResponseSchema,
  RpcSendTransactionRequestSchema,
  RpcSplitStorageInfoRequestSchema,
  RpcSplitStorageInfoResponseSchema,
  RpcStateChangesInBlockByTypeRequestSchema,
  RpcStateChangesInBlockByTypeResponseSchema,
  RpcStateChangesInBlockRequestSchema,
  RpcStateChangesInBlockResponseSchema,
  RpcStatusRequestSchema,
  RpcStatusResponseSchema,
  RpcTransactionResponseSchema,
  RpcTransactionStatusRequestSchema,
  RpcValidatorRequestSchema,
  RpcValidatorResponseSchema,
  RpcValidatorsOrderedRequestSchema,
} from '@near-js/jsonrpc-types';

// Re-export non-validation convenience functions
export { parseCallResultToJson, viewFunctionAsJson } from '../convenience.js';

// Empty enableValidation function (validation is always enabled in these exports)
export function enableValidation(): void {
  // Intentionally empty - validation is always enabled for these exports
}

// Convenience function wrappers with validation
export async function viewAccount(
  client: NearRpcClient,
  params: {
    accountId: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }
): Promise<AccountView> {
  // Use the validated query function
  const queryParams = params.blockId
    ? {
        requestType: 'view_account' as const,
        accountId: params.accountId,
        blockId: params.blockId,
      }
    : {
        requestType: 'view_account' as const,
        accountId: params.accountId,
        finality: params.finality || ('final' as const),
      };

  return query(client, queryParams) as Promise<AccountView>;
}

export async function viewFunction(
  client: NearRpcClient,
  params: {
    accountId: string;
    methodName: string;
    argsBase64?: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }
): Promise<CallResult> {
  // Use the validated query function
  const baseParams = {
    requestType: 'call_function' as const,
    accountId: params.accountId,
    methodName: params.methodName,
    argsBase64: params.argsBase64 ?? '',
  };

  const queryParams = params.blockId
    ? { ...baseParams, blockId: params.blockId }
    : { ...baseParams, finality: params.finality || ('final' as const) };

  return query(client, queryParams) as Promise<CallResult>;
}

export async function viewAccessKey(
  client: NearRpcClient,
  params: {
    accountId: string;
    publicKey: string;
    finality?: 'final' | 'near-final' | 'optimistic';
    blockId?: string | number;
  }
): Promise<AccessKeyView> {
  // Use the validated query function
  const queryParams = params.blockId
    ? {
        requestType: 'view_access_key' as const,
        accountId: params.accountId,
        publicKey: params.publicKey,
        blockId: params.blockId,
      }
    : {
        requestType: 'view_access_key' as const,
        accountId: params.accountId,
        publicKey: params.publicKey,
        finality: params.finality || ('final' as const),
      };

  return query(client, queryParams) as Promise<AccessKeyView>;
}

// Validation wrapper functions
export async function experimentalChanges(
  client: NearRpcClient,
  params?: RpcStateChangesInBlockByTypeRequest
): Promise<RpcStateChangesInBlockResponse> {
  // Validate request parameters
  const requestSchema = RpcStateChangesInBlockByTypeRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalChanges(client, params);

  // Validate response
  const responseSchema = RpcStateChangesInBlockResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalChangesInBlock(
  client: NearRpcClient,
  params?: RpcStateChangesInBlockRequest
): Promise<RpcStateChangesInBlockByTypeResponse> {
  // Validate request parameters
  const requestSchema = RpcStateChangesInBlockRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalChangesInBlock(client, params);

  // Validate response
  const responseSchema = RpcStateChangesInBlockByTypeResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalCongestionLevel(
  client: NearRpcClient,
  params?: RpcCongestionLevelRequest
): Promise<RpcCongestionLevelResponse> {
  // Validate request parameters
  const requestSchema = RpcCongestionLevelRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalCongestionLevel(
    client,
    params
  );

  // Validate response
  const responseSchema = RpcCongestionLevelResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalGenesisConfig(
  client: NearRpcClient,
  params?: GenesisConfigRequest
): Promise<GenesisConfig> {
  // Validate request parameters
  const requestSchema = GenesisConfigRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalGenesisConfig(client, params);

  // Validate response
  const responseSchema = GenesisConfigSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalLightClientBlockProof(
  client: NearRpcClient,
  params?: RpcLightClientBlockProofRequest
): Promise<RpcLightClientBlockProofResponse> {
  // Validate request parameters
  const requestSchema = RpcLightClientBlockProofRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalLightClientBlockProof(
    client,
    params
  );

  // Validate response
  const responseSchema = RpcLightClientBlockProofResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalLightClientProof(
  client: NearRpcClient,
  params?: RpcLightClientExecutionProofRequest
): Promise<RpcLightClientExecutionProofResponse> {
  // Validate request parameters
  const requestSchema = RpcLightClientExecutionProofRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalLightClientProof(
    client,
    params
  );

  // Validate response
  const responseSchema = RpcLightClientExecutionProofResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalMaintenanceWindows(
  client: NearRpcClient,
  params?: RpcMaintenanceWindowsRequest
): Promise<EXPERIMENTALMaintenanceWindowsResponse> {
  // Validate request parameters
  const requestSchema = RpcMaintenanceWindowsRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function (no response validation needed)
  return baseFunctions.experimentalMaintenanceWindows(client, params);
}

export async function experimentalProtocolConfig(
  client: NearRpcClient,
  params?: RpcProtocolConfigRequest
): Promise<RpcProtocolConfigResponse> {
  // Validate request parameters
  const requestSchema = RpcProtocolConfigRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalProtocolConfig(client, params);

  // Validate response
  const responseSchema = RpcProtocolConfigResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalReceipt(
  client: NearRpcClient,
  params?: RpcReceiptRequest
): Promise<RpcReceiptResponse> {
  // Validate request parameters
  const requestSchema = RpcReceiptRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalReceipt(client, params);

  // Validate response
  const responseSchema = RpcReceiptResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalSplitStorageInfo(
  client: NearRpcClient,
  params?: RpcSplitStorageInfoRequest
): Promise<RpcSplitStorageInfoResponse> {
  // Validate request parameters
  const requestSchema = RpcSplitStorageInfoRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalSplitStorageInfo(
    client,
    params
  );

  // Validate response
  const responseSchema = RpcSplitStorageInfoResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalTxStatus(
  client: NearRpcClient,
  params?: RpcTransactionStatusRequest
): Promise<RpcTransactionResponse> {
  // Validate request parameters
  const requestSchema = RpcTransactionStatusRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.experimentalTxStatus(client, params);

  // Validate response
  const responseSchema = RpcTransactionResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function experimentalValidatorsOrdered(
  client: NearRpcClient,
  params?: RpcValidatorsOrderedRequest
): Promise<EXPERIMENTALValidatorsOrderedResponse> {
  // Validate request parameters
  const requestSchema = RpcValidatorsOrderedRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function (no response validation needed)
  return baseFunctions.experimentalValidatorsOrdered(client, params);
}

export async function block(
  client: NearRpcClient,
  params?: RpcBlockRequest
): Promise<RpcBlockResponse> {
  // Validate request parameters
  const requestSchema = RpcBlockRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.block(client, params);

  // Validate response
  const responseSchema = RpcBlockResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function broadcastTxAsync(
  client: NearRpcClient,
  params?: RpcSendTransactionRequest
): Promise<CryptoHash> {
  // Validate request parameters
  const requestSchema = RpcSendTransactionRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.broadcastTxAsync(client, params);

  // Validate response
  const responseSchema = CryptoHashSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function broadcastTxCommit(
  client: NearRpcClient,
  params?: RpcSendTransactionRequest
): Promise<RpcTransactionResponse> {
  // Validate request parameters
  const requestSchema = RpcSendTransactionRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.broadcastTxCommit(client, params);

  // Validate response
  const responseSchema = RpcTransactionResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function changes(
  client: NearRpcClient,
  params?: RpcStateChangesInBlockByTypeRequest
): Promise<RpcStateChangesInBlockResponse> {
  // Validate request parameters
  const requestSchema = RpcStateChangesInBlockByTypeRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.changes(client, params);

  // Validate response
  const responseSchema = RpcStateChangesInBlockResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function chunk(
  client: NearRpcClient,
  params?: RpcChunkRequest
): Promise<RpcChunkResponse> {
  // Validate request parameters
  const requestSchema = RpcChunkRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.chunk(client, params);

  // Validate response
  const responseSchema = RpcChunkResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function clientConfig(
  client: NearRpcClient,
  params?: RpcClientConfigRequest
): Promise<RpcClientConfigResponse> {
  // Validate request parameters
  const requestSchema = RpcClientConfigRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.clientConfig(client, params);

  // Validate response
  const responseSchema = RpcClientConfigResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function gasPrice(
  client: NearRpcClient,
  params?: RpcGasPriceRequest
): Promise<RpcGasPriceResponse> {
  // Validate request parameters
  const requestSchema = RpcGasPriceRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.gasPrice(client, params);

  // Validate response
  const responseSchema = RpcGasPriceResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function health(
  client: NearRpcClient,
  params?: RpcHealthRequest
): Promise<RpcHealthResponse> {
  // Validate request parameters
  const requestSchema = RpcHealthRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.health(client, params);

  // Validate response
  const responseSchema = RpcHealthResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function lightClientProof(
  client: NearRpcClient,
  params?: RpcLightClientExecutionProofRequest
): Promise<RpcLightClientExecutionProofResponse> {
  // Validate request parameters
  const requestSchema = RpcLightClientExecutionProofRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.lightClientProof(client, params);

  // Validate response
  const responseSchema = RpcLightClientExecutionProofResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function networkInfo(
  client: NearRpcClient,
  params?: RpcNetworkInfoRequest
): Promise<RpcNetworkInfoResponse> {
  // Validate request parameters
  const requestSchema = RpcNetworkInfoRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.networkInfo(client, params);

  // Validate response
  const responseSchema = RpcNetworkInfoResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function nextLightClientBlock(
  client: NearRpcClient,
  params?: RpcLightClientNextBlockRequest
): Promise<RpcLightClientNextBlockResponse> {
  // Validate request parameters
  const requestSchema = RpcLightClientNextBlockRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.nextLightClientBlock(client, params);

  // Validate response
  const responseSchema = RpcLightClientNextBlockResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function query(
  client: NearRpcClient,
  params?: RpcQueryRequest
): Promise<RpcQueryResponse> {
  // Validate request parameters
  const requestSchema = RpcQueryRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.query(client, params);

  // Validate response
  const responseSchema = RpcQueryResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function sendTx(
  client: NearRpcClient,
  params?: RpcSendTransactionRequest
): Promise<RpcTransactionResponse> {
  // Validate request parameters
  const requestSchema = RpcSendTransactionRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.sendTx(client, params);

  // Validate response
  const responseSchema = RpcTransactionResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function status(
  client: NearRpcClient,
  params?: RpcStatusRequest
): Promise<RpcStatusResponse> {
  // Validate request parameters
  const requestSchema = RpcStatusRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.status(client, params);

  // Validate response
  const responseSchema = RpcStatusResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function tx(
  client: NearRpcClient,
  params?: RpcTransactionStatusRequest
): Promise<RpcTransactionResponse> {
  // Validate request parameters
  const requestSchema = RpcTransactionStatusRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.tx(client, params);

  // Validate response
  const responseSchema = RpcTransactionResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}

export async function validators(
  client: NearRpcClient,
  params?: RpcValidatorRequest
): Promise<RpcValidatorResponse> {
  // Validate request parameters
  const requestSchema = RpcValidatorRequestSchema();
  if (params !== undefined) {
    try {
      requestSchema.parse(params);
    } catch (error) {
      throw new Error(`Request validation failed: ${error}`);
    }
  }

  // Call the base function
  const result = await baseFunctions.validators(client, params);

  // Validate response
  const responseSchema = RpcValidatorResponseSchema();
  try {
    // Wrap in JSON-RPC response format for validation
    responseSchema.parse(result);
  } catch (error) {
    throw new Error(`Response validation failed: ${error}`);
  }

  return result;
}
